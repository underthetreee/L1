1. Какой самый эффективный способ конкатенации строк?
Ответ:
Метод Join из пакета strings. Этот метод эффективен, потому что внутри него используется strings.Builder,
который выделяет память заранее и уменьшает количество аллокаций памяти,
что может привести к улучшению производительности, особенно при больших объемах данных.

2. Что такое интерфейсы, как они применяются в Go?
Ответ:
Интерфейс это контракт, который содержит набор методов без конкретной реализации. Тип данных, который реализовал набор методов интерфейса, считается типом данных реализующим интерфейс.
Применение интерфейсов в Go:
1) позволяют создавать функции и методы, которые работают с несколькими типами данных, если они реализуют определенный интерфейс.
2) позволяют снизить связанность (coupling) между компонентами программы.
3) упрощают тестирование, так как позволяют создавать моки.

3. Чем отличаются RWMutex от Mutex?
Ответ:
Mutex и RWMutex - типы синхронизации, используемые для управления доступом к общим данным из нескольких горутин.
Mutex:
- позволяет только эксклюзивный доступ к общим данным.
- эффективнее в случае, когда доступ к общим данным требуется только для записи.

RWMutex:
- позволяет одновременно нескольким горутинам читать общие данные, но только одной горутине изменять их.
- эффективен в случаях, где большая часть операций является чтением, и иногда проиходит запись.

4. Чем отличаются буферизированные и не буферизированные каналы?
Ответ:
Не буферизированные:
- отправка и получение данных происходит синхронно из стека одной горутины в стек другой.
- отравляющая горутина блокируется, если нет горутины для приема данных.
- получающая горутина так же блокируется, если нет горутины для отправки данных.

Буферизированные:
- имеют буфер фиксированного размера.
- отправляющая горутина блокируется, если буфер полон и нет читающей горутины.

5. Какой размер у структуры struct{}{}?
Ответ:
Размер пустой структуры равен нулю, так как в ней нет полей.

6. Есть ли в Go перегрузка методов или операторов?
Ответ:
В Go нет возможности перегрузки методов или операторов.

7. В какой последовательности будут выведены элементы map[int]int?
Ответ:
В случайной, в Go нет гарантий порядка итераций по элементам map.

8. В чем разница make и new?
Ответ:
make:
- используется для выделения памяти и инициализации slice, map, channel
new:
- используется для выделения памяти для заданного типа данных, возвращая указатель.
- не инициализирует память.

9. Сколько существует способов задать переменную типа slice или map?
Ответ:
1) через литералы
slice := []int{1, 2, 3}
m := map[string]int{"a": 1, "b": 2}

2) через make():
slice := make([]int, 5)
m := make(map[string]int)

3) через var:
var slice []int
var m map[string]int

10. Что выведет данная программа и почему?
func update(p *int) {
  b := 2
  p = &b
}

func main() {
  var (
     a = 1
     p = &a
  )
  fmt.Println(*p)
  update(p)
  fmt.Println(*p)
}

Ответ:
Выведет 1 1. Так как в функции update, когда мы передаем указатель p по значению, изменение адреса переменной a на адрес переменной b происходит только внутри функции update.
Когда функция update завершается, изменения, внесенные в указатель p, теряются. В результате указатель p продолжает указывать на переменную a, а не на переменную b.
Поэтому оба вызова fmt.Println(*p) выводят значение переменной a, которое остается равным 1.

11. Что выведет данная программа и почему?
func main() {
  wg := sync.WaitGroup{}
  for i := 0; i < 5; i++ {
     wg.Add(1)
     go func(wg sync.WaitGroup, i int) {
        fmt.Println(i)
        wg.Done()
     }(wg, i)
  }
  wg.Wait()
  fmt.Println("exit")
}

Ответ:
Должна вывести числа от 0 до 4 в случайном порядке и exit, но зависает в ожидании.
Проблема в передаче WaitGroup по значению, а не по ссылке в горутину. В таком случае каждая горутина получает копию, а не оригинал WaitGroup.
Из-за этого копии WaitGroup в горутине не будут влиять на оригинальный wg. Поэтому вызов wg.Done() в каждой горутине не будет уменьшать счётчик в оригинальном wg и программа зависнет в ожидании wg.Wait().


12. Что выведет данная программа и почему?
func main() {
  n := 0
  if true {
     n := 1
     n++
  }
  fmt.Println(n)

  Ответ:
  Выведет 0. Переменные, объявленные внутри if находятся в локальной области видимости данного блока. Поэтому n++ увеличивает значение только внутренней переменной, не влияя на внешнюю.

13. Что выведет данная программа и почему?
func someAction(v []int8, b int8) {
  v[0] = 100
  v = append(v, b)
}

func main() {
  var a = []int8{1, 2, 3, 4, 5}
  someAction(a, 6)
  fmt.Println(a)
}

Ответ:
Выведет [100 2 3 4 5]. При вызове someAction, срез a передаётся по значению, но сам срез является ссылкой на массив. Таким образом v[0] = 100 меняет значение элемента a.
При v = append(v, b) создается новый слайс, который ссылается на новый массив, содержащий все элементы из исходного слайса v плюс новый элемент b. Этот новый слайс не влияет на оригинальный слайс a.
Поэтому после вызова someAction, в слайсе a меняется только первый элемент.

14. Что выведет данная программа и почему?
func main() {
  slice := []string{"a", "a"}

  func(slice []string) {
     slice = append(slice, "a")
     slice[0] = "b"
     slice[1] = "b"
     fmt.Print(slice)
  }(slice)
  fmt.Print(slice)
}

Ответ:
Выведет [bbb] [ab]. Потому что slice = append(slice, "a"), создает новый локальный слайс, поэтому slice[0], slice[1] изменяют его, а не оригиналный слайc.
